import{I as K,T as R,a as Z,b as z}from"./ImageFormatPlugin-BkWqR_I0.js";import{l as b,M as u,b9 as Q,d as $,V as tt}from"./three.module-CQU0seT4.js";import{T as et,X as ot}from"./TMSImageSource-BhasGIwp.js";const N=new b,B=new b;function st(h,t,e){const o=e+1e-5;let s=t+1e-5;Math.abs(s)>Math.PI/2&&(s=s-1e-5),h.getCartographicToPosition(t,e,0,N),h.getCartographicToPosition(s,e,0,B);const n=N.distanceTo(B)/1e-5;return h.getCartographicToPosition(t,o,0,B),[N.distanceTo(B)/1e-5,n]}const nt=30,it=15,W=new b,Y=new b,l=new tt,F=new $;class H extends K{get projection(){return this.tiling.projection}constructor(t={}){const{shape:e="planar",endCaps:i=!0,...o}=t;super(o),this.shape=e,this.endCaps=i}async parseToMesh(t,e,...i){const o=await super.parseToMesh(t,e,...i),{shape:s,projection:n,tiles:r,tiling:c}=this;if(s==="ellipsoid"){const P=r.ellipsoid,y=e[R],j=e[Z],w=e[z],[C,D,U,X]=c.getTileBounds(j,w,y,!0),[v,m,E,g]=e.boundingVolume.region,S=Math.ceil((g-m)*u.RAD2DEG*.25),A=Math.ceil((E-v)*u.RAD2DEG*.25),L=Math.max(it,S),V=Math.max(nt,A),_=new Q(1,1,V,L),{position:d,normal:f,uv:x}=_.attributes,I=d.count;e.cached.boundingVolume.getSphere(F);for(let a=0;a<I;a++){W.fromBufferAttribute(d,a),Y.fromBufferAttribute(f,a),l.fromBufferAttribute(x,a);const M=u.mapLinear(l.x,0,1,v,E);let p=u.mapLinear(l.y,0,1,m,g);if(n.isMercator&&l.y!==0&&l.y!==1){const T=n.convertProjectionToLatitude(1),G=1/L,q=u.mapLinear(l.y-G,0,1,m,g),J=u.mapLinear(l.y+G,0,1,m,g);p>T&&q<T&&(p=T),p<-T&&J>-T&&(p=-T)}P.getCartographicToPosition(p,M,0,W).sub(F.center),P.getCartographicToNormal(p,M,Y);const O=u.mapLinear(n.convertLongitudeToProjection(M),C,U,0,1),k=u.mapLinear(n.convertLatitudeToProjection(p),D,X,0,1);x.setXY(a,O,k),d.setXYZ(a,...W),f.setXYZ(a,...Y)}o.geometry=_,o.position.copy(F.center)}return o}createBoundingVolume(t,e,i){if(this.shape==="ellipsoid"){const{tiling:o,endCaps:s}=this,n=i===-1,r=n?o.getFullBounds(!0):o.getTileBounds(t,e,i,!0),c=n?o.getFullBounds():o.getTileBounds(t,e,i);return s&&(r[3]===1&&(c[3]=Math.PI/2),r[1]===0&&(c[1]=-Math.PI/2)),{region:[...c,-1,1]}}else return super.createBoundingVolume(t,e,i)}preprocessNode(t,...e){super.preprocessNode(t,e);const{shape:i,projection:o,tiling:s}=this;if(i==="ellipsoid"){const n=t[R],r=t[Z],c=t[z];if(n===-1)return t.geometricError=1e50,parent;const[P,y,j,w]=s.getTileBounds(r,c,n,!0),{tilePixelWidth:C,tilePixelHeight:D}=s.getLevel(n),{pixelWidth:U,pixelHeight:X}=s.getLevel(s.maxLevel),v=(j-P)/C,m=(w-y)/D,E=1/U,g=1/X,[,S,A,L]=s.getTileBounds(r,c,n),V=S>0!=L>0?0:Math.min(Math.abs(S),Math.abs(L)),_=o.convertLatitudeToProjection(V),d=o.getLongitudeDerivativeAtProjection(P),f=o.getLatitudeDerivativeAtProjection(_),[x,I]=st(this.tiles.ellipsoid,V,A),a=Math.max(v*d*x,m*f*I),M=Math.max(E*d*x,g*f*I);t.geometricError=a-M,t.parent===null&&(t.geometricError=1e50)}return t}}class ut extends H{constructor(t={}){const{pixelSize:e=1e-5,levels:i,tileDimension:o,projection:s,bounds:n,...r}=t;super({pixelSize:e,...r}),this.name="XYZ_TILES_PLUGIN",this.imageSource=new ot({levels:i,tileDimension:o,projection:s,bounds:n})}}class pt extends H{constructor(t){super(t),this.name="TMS_TILES_PLUGIN",this.imageSource=new et}}export{pt as T,ut as X};
//# sourceMappingURL=EPSGTilesPlugin-_FiPb7b9.js.map
