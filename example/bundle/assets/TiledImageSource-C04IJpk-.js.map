{"version":3,"file":"TiledImageSource-C04IJpk-.js","sources":["../../../src/three/plugins/images/utils/DataCache.js","../../../src/three/plugins/images/utils/TilingScheme.js","../../../src/three/plugins/images/sources/TiledImageSource.js"],"sourcesContent":["function hash( ...args ) {\n\n\treturn args.join( '_' );\n\n}\n\n// class for retrieving and locking data being requested\n// \"fetchItem\" and \"disposeItem\" should be implemented\nexport class DataCache {\n\n\tconstructor() {\n\n\t\tthis.cache = {};\n\t\tthis.count = 0;\n\t\tthis.cachedBytes = 0;\n\t\tthis.active = 0;\n\n\t}\n\n\t// overridable\n\tfetchItem() {}\n\tdisposeItem() {}\n\tgetMemoryUsage( item ) {\n\n\t\treturn 0;\n\n\t}\n\n\t// sets the data in the cache explicitly without need to load\n\tsetData( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst data = args.pop();\n\t\tconst key = hash( ...args );\n\t\tif ( key in cache ) {\n\n\t\t\tthrow new Error( `DataCache: \"${ key }\" is already present.` );\n\n\t\t} else {\n\n\t\t\tthis.cache[ key ] = {\n\t\t\t\tabortController: new AbortController(),\n\t\t\t\tresult: data,\n\t\t\t\tcount: 1,\n\t\t\t\tbytes: this.getMemoryUsage( data ),\n\t\t\t};\n\t\t\tthis.count ++;\n\t\t\tthis.cachedBytes += this.cache[ key ].bytes;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\t// fetches the associated data if it doesn't exist and increments the lock counter\n\tlock( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst key = hash( ...args );\n\t\tif ( key in cache ) {\n\n\t\t\tcache[ key ].count ++;\n\n\t\t} else {\n\n\t\t\tconst abortController = new AbortController();\n\t\t\tconst info = {\n\t\t\t\tabortController,\n\t\t\t\tresult: null,\n\t\t\t\tcount: 1,\n\t\t\t\tbytes: 0,\n\t\t\t};\n\n\t\t\tthis.active ++;\n\t\t\tinfo.result = this.fetchItem( args, abortController.signal );\n\t\t\tif ( info.result instanceof Promise ) {\n\n\t\t\t\tinfo.result.then( res => {\n\n\t\t\t\t\tinfo.result = res;\n\t\t\t\t\tinfo.bytes = this.getMemoryUsage( res );\n\t\t\t\t\tthis.cachedBytes += info.bytes;\n\t\t\t\t\treturn res;\n\n\t\t\t\t} ).finally( () => {\n\n\t\t\t\t\tthis.active --;\n\n\t\t\t\t} ).catch( e => {\n\n\t\t\t\t\t// error logging and handling can be handled elsewhere\n\n\t\t\t\t} );\n\n\t\t\t} else {\n\n\t\t\t\tthis.active --;\n\t\t\t\tinfo.bytes = this.getMemoryUsage( info.result );\n\t\t\t\tthis.cachedBytes += info.bytes;\n\n\t\t\t}\n\n\t\t\tthis.cache[ key ] = info;\n\t\t\tthis.count ++;\n\n\t\t}\n\n\t\treturn cache[ key ].result;\n\n\t}\n\n\t// decrements the lock counter for the item and deletes the item if it has reached zero\n\trelease( ...args ) {\n\n\t\tconst key = hash( ...args );\n\t\tthis.releaseViaFullKey( key );\n\n\t}\n\n\t// get the loaded item\n\tget( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst key = hash( ...args );\n\t\tif ( key in cache && cache[ key ].count > 0 ) {\n\n\t\t\treturn cache[ key ].result;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\thas( ...args ) {\n\n\t\tconst { cache } = this;\n\t\tconst key = hash( ...args );\n\t\treturn key in cache;\n\n\t}\n\n\t// dispose all items\n\tdispose() {\n\n\t\tconst { cache } = this;\n\t\tfor ( const key in cache ) {\n\n\t\t\tconst { abortController } = cache[ key ];\n\t\t\tabortController.abort();\n\n\t\t\tthis.releaseViaFullKey( key, true );\n\n\t\t}\n\n\t\tthis.cache = {};\n\n\t}\n\n\t// releases an item with an optional force flag\n\treleaseViaFullKey( key, force = false ) {\n\n\t\tconst { cache } = this;\n\t\tif ( key in cache && cache[ key ].count > 0 ) {\n\n\t\t\t// decrement the lock\n\t\t\tconst info = cache[ key ];\n\t\t\tinfo.count --;\n\n\t\t\t// if the item is no longer being used\n\t\t\tif ( info.count === 0 || force ) {\n\n\t\t\t\tconst disposeCallback = () => {\n\n\t\t\t\t\t// if the object isn't in the cache anymore then exit early because it's been disposed elsewhere\n\t\t\t\t\tif ( cache[ key ] !== info ) {\n\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// abort any loads\n\t\t\t\t\tconst { result, abortController } = info;\n\t\t\t\t\tabortController.abort();\n\n\t\t\t\t\t// dispose of the object even if it still is in progress\n\t\t\t\t\tif ( result instanceof Promise ) {\n\n\t\t\t\t\t\t// \"disposeItem\" will throw potentially if fetch, etc are cancelled using the abort signal\n\t\t\t\t\t\tresult.then( item => {\n\n\t\t\t\t\t\t\tthis.disposeItem( item );\n\t\t\t\t\t\t\tthis.count --;\n\t\t\t\t\t\t\tthis.cachedBytes -= info.bytes;\n\n\t\t\t\t\t\t} ).catch( () => {} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.disposeItem( result );\n\t\t\t\t\t\tthis.count --;\n\t\t\t\t\t\tthis.cachedBytes -= info.bytes;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete cache[ key ];\n\n\t\t\t\t};\n\n\t\t\t\tif ( force ) {\n\n\t\t\t\t\t// if we're forcing disposal then dispose immediately\n\t\t\t\t\tdisposeCallback();\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// queue for disposal in a frame here - we need to make sure we're not disposing of something twice\n\t\t\t\t\t// this can get called multiple times in a row to increment then decrement again.\n\t\t\t\t\tqueueMicrotask( () => {\n\n\t\t\t\t\t\tif ( info.count === 0 ) {\n\n\t\t\t\t\t\t\tdisposeCallback();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tthrow new Error( 'DataCache: Attempting to release key that does not exist' );\n\n\t}\n\n}\n","// Class for storing and querying a tiling scheme including a bounds, origin, and negative tile indices.\n// Assumes that tiles are split into four child tiles at each level.\nfunction clamp( x, min, max ) {\n\n\treturn Math.min( Math.max( x, min ), max );\n\n}\n\nexport class TilingScheme {\n\n\tget levelCount() {\n\n\t\treturn this._levels.length;\n\n\t}\n\n\tget maxLevel() {\n\n\t\treturn this.levelCount - 1;\n\n\t}\n\n\tget minLevel() {\n\n\t\tconst levels = this._levels;\n\t\tfor ( let i = 0; i < levels.length; i ++ ) {\n\n\t\t\tif ( levels[ i ] !== null ) {\n\n\t\t\t\treturn i;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn - 1;\n\n\t}\n\n\t// prioritize user-set bounds over projection bounds if present\n\tget rootBounds() {\n\n\t\treturn this._rootBounds ?? this.projection?.getBounds() ?? [ 0, 0, 1, 1 ];\n\n\t}\n\n\tget rootOrigin() {\n\n\t\tconst bounds = this.rootBounds;\n\t\treturn this._rootOrigin ?? [ bounds[ 0 ], bounds[ 1 ] ];\n\n\t}\n\n\tget aspectRatio() {\n\n\t\tconst { pixelWidth, pixelHeight } = this.getLevel( this.maxLevel );\n\t\treturn pixelWidth / pixelHeight;\n\n\t}\n\n\tconstructor() {\n\n\t\tthis.flipY = false;\n\t\tthis.pixelOverlap = 0;\n\n\t\t// The origin and bounds\n\t\tthis._rootBounds = null;\n\t\tthis._rootOrigin = null;\n\t\tthis.projection = null;\n\n\t\tthis._levels = [];\n\n\t}\n\n\t// build the zoom levels\n\tsetLevel( level, options = {} ) {\n\n\t\tconst levels = this._levels;\n\t\twhile ( levels.length < level ) {\n\n\t\t\tlevels.push( null );\n\n\t\t}\n\n\t\tconst {\n\t\t\ttilePixelWidth = 256,\n\t\t\ttilePixelHeight = 256,\n\t\t\ttileCountX = 2 ** level,\n\t\t\ttileCountY = 2 ** level,\n\t\t} = options;\n\n\t\tconst {\n\t\t\tpixelWidth = tilePixelWidth * tileCountX,\n\t\t\tpixelHeight = tilePixelHeight * tileCountY,\n\t\t} = options;\n\n\t\tlevels[ level ] = {\n\t\t\ttilePixelWidth,\n\t\t\ttilePixelHeight,\n\t\t\tpixelWidth,\n\t\t\tpixelHeight,\n\t\t\ttileCountX,\n\t\t\ttileCountY,\n\t\t};\n\n\t}\n\n\tgenerateLevels( levels, rootTileX, rootTileY, options = {} ) {\n\n\t\tconst {\n\t\t\tminLevel = 0,\n\t\t\ttilePixelWidth = 256,\n\t\t\ttilePixelHeight = 256,\n\t\t} = options;\n\n\t\tconst maxLevel = levels - 1;\n\t\tconst {\n\t\t\tpixelWidth = tilePixelWidth * rootTileX * ( 2 ** maxLevel ),\n\t\t\tpixelHeight = tilePixelHeight * rootTileY * ( 2 ** maxLevel ),\n\t\t} = options;\n\t\tfor ( let level = minLevel; level < levels; level ++ ) {\n\n\t\t\tconst invLevel = levels - level - 1;\n\t\t\tconst levelPixelWidth = Math.ceil( pixelWidth * ( 2 ** - invLevel ) );\n\t\t\tconst levelPixelHeight = Math.ceil( pixelHeight * ( 2 ** - invLevel ) );\n\t\t\tconst tileCountX = Math.ceil( levelPixelWidth / tilePixelWidth );\n\t\t\tconst tileCountY = Math.ceil( levelPixelHeight / tilePixelHeight );\n\n\t\t\tthis.setLevel( level, {\n\t\t\t\ttilePixelWidth,\n\t\t\t\ttilePixelHeight,\n\t\t\t\tpixelWidth: levelPixelWidth,\n\t\t\t\tpixelHeight: levelPixelHeight,\n\t\t\t\ttileCountX,\n\t\t\t\ttileCountY,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n\tgetLevel( level ) {\n\n\t\treturn this._levels[ level ];\n\n\t}\n\n\t// bounds setters\n\tsetOrigin( x, y ) {\n\n\t\tthis._rootOrigin = [ x, y ];\n\n\t}\n\n\tsetBounds( minX, minY, maxX, maxY ) {\n\n\t\tthis._rootBounds = [ minX, minY, maxX, maxY ];\n\n\t}\n\n\tsetProjection( projection ) {\n\n\t\tthis.projection = projection;\n\n\t}\n\n\t// query functions\n\tgetTileAtPoint( bx, by, level, normalized = false ) {\n\n\t\tconst { projection, flipY } = this;\n\t\tconst { tileCountX, tileCountY } = this.getLevel( level );\n\t\tconst xStride = 1 / tileCountX;\n\t\tconst yStride = 1 / tileCountY;\n\n\t\tif ( projection && ! normalized ) {\n\n\t\t\tbx = projection.convertLongitudeToProjection( bx );\n\t\t\tby = projection.convertLatitudeToProjection( by );\n\n\t\t}\n\n\t\tconst tx = Math.floor( bx / xStride );\n\t\tlet ty = Math.floor( by / yStride );\n\n\t\tif ( flipY ) {\n\n\t\t\tty = tileCountY - 1 - ty;\n\n\t\t}\n\n\t\treturn [ tx, ty ];\n\n\t}\n\n\tgetTilesInRange( minX, minY, maxX, maxY, level, normalized = false ) {\n\n\t\tconst minTile = this.getTileAtPoint( minX, minY, level, normalized, false );\n\t\tconst maxTile = this.getTileAtPoint( maxX, maxY, level, normalized, false );\n\n\t\tif ( this.flipY ) {\n\n\t\t\t[ minTile[ 1 ], maxTile[ 1 ] ] = [ maxTile[ 1 ], minTile[ 1 ] ];\n\n\t\t}\n\n\t\tconst { tileCountX, tileCountY } = this.getLevel( level );\n\t\tconst [ minTileX, minTileY ] = minTile;\n\t\tconst [ maxTileX, maxTileY ] = maxTile;\n\n\t\tif ( maxTileX < 0 || maxTileY < 0 || minTileX >= tileCountX || minTileY >= tileCountY ) {\n\n\t\t\treturn [ 0, 0, - 1, - 1 ];\n\n\t\t}\n\n\t\treturn [\n\t\t\tclamp( minTileX, 0, tileCountX - 1 ),\n\t\t\tclamp( minTileY, 0, tileCountY - 1 ),\n\t\t\tclamp( maxTileX, 0, tileCountX - 1 ),\n\t\t\tclamp( maxTileY, 0, tileCountY - 1 ),\n\t\t];\n\n\t}\n\n\tgetTileExists( x, y, level ) {\n\n\t\tconst [ rminx, rminy, rmaxx, rmaxy ] = this.rootBounds;\n\t\tconst [ tminx, tminy, tmaxx, tmaxy ] = this.getTileBounds( x, y, level );\n\t\tconst isDegenerate = tminx >= tmaxx || tminy >= tmaxy;\n\n\t\t// TODO: is supporting \"just touch\" correct?\n\t\treturn ! isDegenerate && tminx <= rmaxx && tminy <= rmaxy && tmaxx >= rminx && tmaxy >= rminy;\n\n\t}\n\n\tgetFullBounds( normalized = false ) {\n\n\t\tconst { projection } = this;\n\t\tconst bounds = [ ...this.rootBounds ];\n\t\tif ( projection && normalized ) {\n\n\t\t\tbounds[ 0 ] = projection.convertLongitudeToProjection( bounds[ 0 ] );\n\t\t\tbounds[ 1 ] = projection.convertLatitudeToProjection( bounds[ 1 ] );\n\t\t\tbounds[ 2 ] = projection.convertLongitudeToProjection( bounds[ 2 ] );\n\t\t\tbounds[ 3 ] = projection.convertLatitudeToProjection( bounds[ 3 ] );\n\n\t\t}\n\n\t\treturn bounds;\n\n\t}\n\n\tgetTileBounds( x, y, level, normalized = false ) {\n\n\t\tconst { flipY, pixelOverlap, projection } = this;\n\t\tconst { tilePixelWidth, tilePixelHeight, pixelWidth, pixelHeight } = this.getLevel( level );\n\n\t\tlet tileLeft = tilePixelWidth * x - pixelOverlap;\n\t\tlet tileTop = tilePixelHeight * y - pixelOverlap;\n\t\tlet tileRight = tileLeft + tilePixelWidth + pixelOverlap * 2;\n\t\tlet tileBottom = tileTop + tilePixelHeight + pixelOverlap * 2;\n\n\t\t// clamp\n\t\ttileLeft = Math.max( tileLeft, 0 );\n\t\ttileTop = Math.max( tileTop, 0 );\n\t\ttileRight = Math.min( tileRight, pixelWidth );\n\t\ttileBottom = Math.min( tileBottom, pixelHeight );\n\n\t\t// normalized\n\t\ttileLeft = tileLeft / pixelWidth;\n\t\ttileRight = tileRight / pixelWidth;\n\t\ttileTop = tileTop / pixelHeight;\n\t\ttileBottom = tileBottom / pixelHeight;\n\n\t\t// invert y\n\t\tif ( flipY ) {\n\n\t\t\tconst extents = ( tileBottom - tileTop ) / 2;\n\t\t\tconst centerY = ( tileTop + tileBottom ) / 2;\n\t\t\tconst invCenterY = 1.0 - centerY;\n\n\t\t\ttileTop = invCenterY - extents;\n\t\t\ttileBottom = invCenterY + extents;\n\n\t\t}\n\n\t\tconst bounds = [ tileLeft, tileTop, tileRight, tileBottom ];\n\t\tif ( projection && ! normalized ) {\n\n\t\t\tbounds[ 0 ] = projection.convertProjectionToLongitude( bounds[ 0 ] );\n\t\t\tbounds[ 1 ] = projection.convertProjectionToLatitude( bounds[ 1 ] );\n\t\t\tbounds[ 2 ] = projection.convertProjectionToLongitude( bounds[ 2 ] );\n\t\t\tbounds[ 3 ] = projection.convertProjectionToLatitude( bounds[ 3 ] );\n\n\t\t}\n\n\t\treturn bounds;\n\n\t}\n\n\ttoNormalizedPoint( x, y ) {\n\n\t\tconst { projection } = this;\n\t\tconst result = [ x, y ];\n\t\tif ( this.projection ) {\n\n\t\t\tresult[ 0 ] = projection.convertLongitudeToProjection( result[ 0 ] );\n\t\t\tresult[ 1 ] = projection.convertLatitudeToProjection( result[ 1 ] );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\ttoNormalizedRange( range ) {\n\n\t\treturn [\n\t\t\t...this.toNormalizedPoint( range[ 0 ], range[ 1 ] ),\n\t\t\t...this.toNormalizedPoint( range[ 2 ], range[ 3 ] ),\n\t\t];\n\n\t}\n\n\tclampToBounds( range, normalized = false ) {\n\n\t\tconst result = [ ...range ];\n\t\tconst { projection } = this;\n\t\tif ( normalized || ! projection ) {\n\n\t\t\tresult[ 0 ] = clamp( result[ 0 ], 0, 1 );\n\t\t\tresult[ 1 ] = clamp( result[ 1 ], 0, 1 );\n\t\t\tresult[ 2 ] = clamp( result[ 2 ], 0, 1 );\n\t\t\tresult[ 3 ] = clamp( result[ 3 ], 0, 1 );\n\n\t\t} else {\n\n\t\t\tconst [ minX, minY, maxX, maxY ] = projection.getBounds();\n\t\t\tresult[ 0 ] = clamp( result[ 0 ], minX, maxX );\n\t\t\tresult[ 1 ] = clamp( result[ 1 ], minY, maxY );\n\t\t\tresult[ 2 ] = clamp( result[ 2 ], minX, maxX );\n\t\t\tresult[ 3 ] = clamp( result[ 3 ], minY, maxY );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\n","import { DataCache } from '../utils/DataCache.js';\nimport { TilingScheme } from '../utils/TilingScheme.js';\nimport { SRGBColorSpace, Texture } from 'three';\nimport * as THREE from 'three';\n\n// TODO: support queries for detail at level - ie projected pixel size for geometric error mapping\n// Goes here or in \"TilingScheme\"?\nexport class TiledImageSource extends DataCache {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.tiling = new TilingScheme();\n\t\tthis.fetchOptions = {};\n\t\tthis.fetchData = ( ...args ) => fetch( ...args );\n\n\t}\n\n\t// async function for initializing the tiled image set\n\tinit( url ) {\n\n\t}\n\n\t// helper for processing the buffer into a texture\n\tasync processBufferToTexture( buffer ) {\n\n\t\tconst blob = new Blob( [ buffer ] );\n\t\tconst imageBitmap = await createImageBitmap( blob, {\n\t\t\tpremultiplyAlpha: 'none',\n\t\t\tcolorSpaceConversion: 'none',\n\t\t\timageOrientation: 'flipY',\n\t\t} );\n\t\tconst texture = new Texture( imageBitmap );\n\t\ttexture.generateMipmaps = false;\n\t\ttexture.colorSpace = SRGBColorSpace;\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n\tgetMemoryUsage( tex ) {\n\n\t\t// deprecated: remove in next major release\n\t\tconst { TextureUtils } = THREE;\n\t\tif ( ! TextureUtils ) {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst { format, type, image, generateMipmaps } = tex;\n\t\tconst { width, height } = image;\n\t\tconst bytes = TextureUtils.getByteLength( width, height, format, type );\n\t\treturn generateMipmaps ? bytes * 4 / 3 : bytes;\n\n\t}\n\n\t// fetch the item with the given key fields\n\tfetchItem( tokens, signal ) {\n\n\t\tconst fetchOptions = {\n\t\t\t...this.fetchOptions,\n\t\t\tsignal,\n\t\t};\n\t\tconst url = this.getUrl( ...tokens );\n\t\treturn this\n\t\t\t.fetchData( url, fetchOptions )\n\t\t\t.then( res => res.arrayBuffer() )\n\t\t\t.then( buffer => this.processBufferToTexture( buffer ) );\n\n\t}\n\n\t// dispose of the item that was fetched\n\tdisposeItem( texture ) {\n\n\t\ttexture.dispose();\n\t\tif ( texture.image instanceof ImageBitmap ) {\n\n\t\t\ttexture.image.close();\n\n\t\t}\n\n\t}\n\n\tgetUrl( ...args ) {\n\n\t}\n\n}\n"],"names":["hash","args","DataCache","item","cache","data","key","abortController","info","res","e","force","disposeCallback","result","clamp","min","max","TilingScheme","levels","_a","bounds","pixelWidth","pixelHeight","level","options","tilePixelWidth","tilePixelHeight","tileCountX","tileCountY","rootTileX","rootTileY","minLevel","maxLevel","invLevel","levelPixelWidth","levelPixelHeight","x","y","minX","minY","maxX","maxY","projection","bx","by","normalized","flipY","xStride","yStride","tx","ty","minTile","maxTile","minTileX","minTileY","maxTileX","maxTileY","rminx","rminy","rmaxx","rmaxy","tminx","tminy","tmaxx","tmaxy","pixelOverlap","tileLeft","tileTop","tileRight","tileBottom","extents","invCenterY","range","TiledImageSource","url","buffer","blob","imageBitmap","texture","Texture","SRGBColorSpace","tex","TextureUtils","THREE","format","type","image","generateMipmaps","width","height","bytes","tokens","signal","fetchOptions"],"mappings":"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"}