import{h as ft,b9 as Pt,b as gt,V as M,k as J,ae as tt,l as g,aH as yt,at as pt,R as vt,s as xt,Q as ut,M as B}from"./three.module-CQU0seT4.js";class St extends ft{constructor(){super(new Pt(0,0),new _t),this.renderOrder=1/0}onBeforeRender(t){const e=this.material.uniforms;t.getSize(e.resolution.value)}updateMatrixWorld(){this.matrixWorld.makeTranslation(this.position)}dispose(){this.geometry.dispose(),this.material.dispose()}}class _t extends gt{constructor(){super({depthWrite:!1,depthTest:!1,transparent:!0,uniforms:{resolution:{value:new M},size:{value:15},thickness:{value:2},opacity:{value:1}},vertexShader:`

				uniform float pixelRatio;
				uniform float size;
				uniform float thickness;
				uniform vec2 resolution;
				varying vec2 vUv;

				void main() {

					vUv = uv;

					float aspect = resolution.x / resolution.y;
					vec2 offset = uv * 2.0 - vec2( 1.0 );
					offset.y *= aspect;

					vec4 screenPoint = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
					screenPoint.xy += offset * ( size + thickness ) * screenPoint.w / resolution.x;

					gl_Position = screenPoint;

				}
			`,fragmentShader:`

				uniform float size;
				uniform float thickness;
				uniform float opacity;

				varying vec2 vUv;
				void main() {

					float ht = 0.5 * thickness;
					float planeDim = size + thickness;
					float offset = ( planeDim - ht - 2.0 ) / planeDim;
					float texelThickness = ht / planeDim;

					vec2 vec = vUv * 2.0 - vec2( 1.0 );
					float dist = abs( length( vec ) - offset );
					float fw = fwidth( dist ) * 0.5;
					float a = smoothstep( texelThickness - fw, texelThickness + fw, dist );

					gl_FragColor = vec4( 1, 1, 1, opacity * ( 1.0 - a ) );

				}
			`})}}const it=new M,ot=new M;class Dt{constructor(){this.domElement=null,this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new M,this.hoverSet=!1}reset(){this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new M,this.hoverSet=!1}updateFrame(){const{previousPositions:t,pointerPositions:e}=this;for(const i in e)t[i].copy(e[i])}setHoverEvent(t){(t.pointerType==="mouse"||t.type==="wheel")&&(this.getAdjustedPointer(t,this.hoverPosition),this.hoverSet=!0)}getLatestPoint(t){return this.pointerType!==null?(this.getCenterPoint(t),t):this.hoverSet?(t.copy(this.hoverPosition),t):null}getAdjustedPointer(t,e){const o=(this.domElement?this.domElement:t.target).getBoundingClientRect(),s=t.clientX-o.left,d=t.clientY-o.top;e.set(s,d)}addPointer(t){const e=t.pointerId,i=new M;this.getAdjustedPointer(t,i),this.pointerOrder.push(e),this.pointerPositions[e]=i,this.previousPositions[e]=i.clone(),this.startPositions[e]=i.clone(),this.getPointerCount()===1&&(this.pointerType=t.pointerType,this.buttons=t.buttons)}updatePointer(t){const e=t.pointerId;return e in this.pointerPositions?(this.getAdjustedPointer(t,this.pointerPositions[e]),!0):!1}deletePointer(t){const e=t.pointerId,i=this.pointerOrder;i.splice(i.indexOf(e),1),delete this.pointerPositions[e],delete this.previousPositions[e],delete this.startPositions[e],this.getPointerCount.length===0&&(this.buttons=0,this.pointerType=null)}getPointerCount(){return this.pointerOrder.length}getCenterPoint(t,e=this.pointerPositions){const i=this.pointerOrder;if(this.getPointerCount()===1||this.getPointerType()==="mouse"){const o=i[0];return t.copy(e[o]),t}else if(this.getPointerCount()===2){const o=this.pointerOrder[0],s=this.pointerOrder[1],d=e[o],c=e[s];return t.addVectors(d,c).multiplyScalar(.5),t}return null}getPreviousCenterPoint(t){return this.getCenterPoint(t,this.previousPositions)}getStartCenterPoint(t){return this.getCenterPoint(t,this.startPositions)}getMoveDistance(){return this.getCenterPoint(it),this.getPreviousCenterPoint(ot),it.sub(ot).length()}getTouchPointerDistance(t=this.pointerPositions){if(this.getPointerCount()<=1||this.getPointerType()==="mouse")return 0;const{pointerOrder:e}=this,i=e[0],o=e[1],s=t[i],d=t[o];return s.distanceTo(d)}getPreviousTouchPointerDistance(){return this.getTouchPointerDistance(this.previousPositions)}getStartTouchPointerDistance(){return this.getTouchPointerDistance(this.startPositions)}getPointerType(){return this.pointerType}isPointerTouch(){return this.getPointerType()==="touch"}getPointerButtons(){return this.buttons}isLeftClicked(){return!!(this.buttons&1)}isRightClicked(){return!!(this.buttons&2)}}const W=new J,st=new tt,nt=new g;function N(f,t,e){return e.makeTranslation(-f.x,-f.y,-f.z),W.makeRotationFromQuaternion(t),e.premultiply(W),W.makeTranslation(f.x,f.y,f.z),e.premultiply(W),e}function A(f,t,e,i){i.x=(f-e.offsetLeft)/e.clientWidth*2-1,i.y=-((t-e.offsetTop)/e.clientHeight)*2+1,i.isVector3&&(i.z=0)}function zt(f,t,e){return t.intersectRay(f,e)?e:(W.makeScale(...t.radius).invert(),st.copy(f).applyMatrix4(W),nt.set(0,0,0),st.closestPointToPoint(nt,e).normalize(),W.makeScale(...t.radius),e.applyMatrix4(W))}function w(f,t,e){const i=f instanceof tt?f:f.ray,{origin:o,direction:s}=i;o.set(t.x,t.y,-1).unproject(e),s.set(t.x,t.y,1).unproject(e).sub(o),f.isRay||(f.near=0,f.far=s.length(),f.camera=e),s.normalize()}const C=0,E=1,T=2,O=3,Q=4,G=.05,Y=.025,k=new J,L=new J,D=new g,h=new g,H=new g,j=new g,S=new g,b=new g,$=new g,Z=new g,z=new ut,rt=new pt,P=new g,q=new g,K=new g,Mt=new ut,m=new tt,F=new M,v=new M,at=new M,V=new M,X=new M,ct=new M,lt={type:"change"},ht={type:"start"},dt={type:"end"};class Ct extends yt{get enabled(){return this._enabled}set enabled(t){t!==this.enabled&&(this._enabled=t,this.resetState(),this.pointerTracker.reset(),this.enabled||(this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0)))}constructor(t=null,e=null,i=null,o=null){super(),this.isEnvironmentControls=!0,this.domElement=null,this.camera=null,this.scene=null,this.tilesRenderer=null,this._enabled=!0,this.cameraRadius=5,this.rotationSpeed=1,this.minAltitude=0,this.maxAltitude=.45*Math.PI,this.minDistance=10,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.zoomSpeed=1,this.adjustHeight=!0,this.enableDamping=!1,this.dampingFactor=.15,this.fallbackPlane=new pt(new g(0,1,0),0),this.useFallbackPlane=!0,this.scaleZoomOrientationAtEdges=!1,this.autoAdjustCameraRotation=!0,this.state=C,this.pointerTracker=new Dt,this.needsUpdate=!1,this.actionHeightOffset=0,this.pivotPoint=new g,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.zoomDirection=new g,this.zoomPoint=new g,this.zoomDelta=0,this.rotationInertiaPivot=new g,this.rotationInertia=new M,this.dragInertia=new g,this.inertiaTargetDistance=1/0,this.inertiaStableFrames=0,this.pivotMesh=new St,this.pivotMesh.raycast=()=>{},this.pivotMesh.scale.setScalar(.25),this.raycaster=new vt,this.raycaster.firstHitOnly=!0,this.up=new g(0,1,0),this.clock=new xt,this._detachCallback=null,this._upInitialized=!1,this._lastUsedState=C,this._zoomPointWasSet=!1,this._tilesOnChangeCallback=()=>this.zoomPointSet=!1,i&&this.attach(i),e&&this.setCamera(e),t&&this.setScene(t),o&&this.setTilesRenderer(o)}setScene(t){this.scene=t}setCamera(t){this.camera=t,this._upInitialized=!1,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.needsUpdate=!0,this.raycaster.camera=t,this.resetState()}setTilesRenderer(t){console.warn('EnvironmentControls: "setTilesRenderer" has been deprecated. Use "setScene" and "setEllipsoid", instead.'),this.tilesRenderer=t,this.tilesRenderer!==null&&this.setScene(this.tilesRenderer.group)}attach(t){if(this.domElement)throw new Error("EnvironmentControls: Controls already attached to element");this.domElement=t,this.pointerTracker.domElement=t,t.style.touchAction="none";const e=n=>{this.enabled&&n.preventDefault()},i=n=>{if(!this.enabled)return;n.preventDefault();const{camera:a,raycaster:r,domElement:_,up:x,pivotMesh:p,pointerTracker:y,scene:R,pivotPoint:I,enabled:mt}=this;if(y.addPointer(n),this.needsUpdate=!0,y.isPointerTouch()){if(p.visible=!1,y.getPointerCount()===0)_.setPointerCapture(n.pointerId);else if(y.getPointerCount()>2){this.resetState();return}}y.getCenterPoint(v),A(v.x,v.y,_,v),w(r,v,a);const et=Math.abs(r.ray.direction.dot(x));if(et<G||et<Y)return;const U=this._raycast(r);U&&(y.getPointerCount()===2||y.isRightClicked()||y.isLeftClicked()&&n.shiftKey?(this.setState(y.isPointerTouch()?Q:T),I.copy(U.point),p.position.copy(U.point),p.visible=y.isPointerTouch()?!1:mt,p.updateMatrixWorld(),R.add(p)):y.isLeftClicked()&&(this.setState(E),I.copy(U.point),p.position.copy(U.point),p.updateMatrixWorld(),R.add(p)))};let o=!1;const s=n=>{const{pointerTracker:a}=this;if(!this.enabled||a.getPointerCount()===0)return;n.preventDefault();const{pivotMesh:r,enabled:_}=this;this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.state!==C&&(this.needsUpdate=!0),a.setHoverEvent(n),a.updatePointer(n)&&(a.isPointerTouch()&&a.getPointerCount()===2&&(o||(o=!0,queueMicrotask(()=>{o=!1,a.getCenterPoint(X);const x=a.getStartTouchPointerDistance(),p=a.getTouchPointerDistance(),y=p-x;if(this.state===C||this.state===Q){a.getCenterPoint(X),a.getStartCenterPoint(ct);const R=2*window.devicePixelRatio,I=X.distanceTo(ct);(Math.abs(y)>R||I>R)&&(Math.abs(y)>I?(this.setState(O),this.zoomDirectionSet=!1):this.setState(T))}if(this.state===O){const R=a.getPreviousTouchPointerDistance();this.zoomDelta+=p-R,r.visible=!1}else this.state===T&&(r.visible=_)}))),this.dispatchEvent(lt))},d=n=>{const{pointerTracker:a}=this;!this.enabled||a.getPointerCount()===0||(a.deletePointer(n),a.getPointerType()==="touch"&&a.getPointerCount()===0&&t.releasePointerCapture(n.pointerId),this.resetState(),this.needsUpdate=!0)},c=n=>{if(!this.enabled)return;n.preventDefault();const{pointerTracker:a}=this;a.setHoverEvent(n),a.updatePointer(n),this.dispatchEvent(ht);let r;switch(n.deltaMode){case 2:r=n.deltaY*800;break;case 1:r=n.deltaY*40;break;case 0:r=n.deltaY;break}const _=Math.sign(r),x=Math.abs(r);this.zoomDelta-=.25*_*x,this.needsUpdate=!0,this._lastUsedState=O,this.dispatchEvent(dt)},u=n=>{const{pointerTracker:a}=this;!this.enabled||a.getPointerCount()===0||this.resetState()};t.addEventListener("contextmenu",e),t.addEventListener("pointerdown",i),t.addEventListener("wheel",c,{passive:!1});const l=t.getRootNode();l.addEventListener("pointermove",s),l.addEventListener("pointerup",d),l.addEventListener("pointerleave",u),this._detachCallback=()=>{t.removeEventListener("contextmenu",e),t.removeEventListener("pointerdown",i),t.removeEventListener("wheel",c),l.removeEventListener("pointermove",s),l.removeEventListener("pointerup",d),l.removeEventListener("pointerleave",u)}}detach(){this.domElement=null,this._detachCallback&&(this._detachCallback(),this._detachCallback=null,this.pointerTracker.reset())}getUpDirection(t,e){e.copy(this.up)}getCameraUpDirection(t){this.getUpDirection(this.camera.position,t)}getPivotPoint(t){let e=null;this._lastUsedState===O?this._zoomPointWasSet&&(e=t.copy(this.zoomPoint)):(this._lastUsedState===T||this._lastUsedState===E)&&(e=t.copy(this.pivotPoint));const{camera:i,raycaster:o}=this;e!==null&&(h.copy(e).project(i),(h.x<-1||h.x>1||h.y<-1||h.y>1)&&(e=null)),w(o,{x:0,y:0},i);const s=this._raycast(o);return s&&(e===null||s.distance<e.distanceTo(o.ray.origin))&&(e=t.copy(s.point)),e}resetState(){this.state!==C&&this.dispatchEvent(dt),this.state=C,this.pivotMesh.removeFromParent(),this.pivotMesh.visible=this.enabled,this.actionHeightOffset=0,this.pointerTracker.reset()}setState(t=this.state,e=!0){this.state!==t&&(this.state===C&&e&&this.dispatchEvent(ht),this.pivotMesh.visible=this.enabled,this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0),this.inertiaStableFrames=0,this.state=t,t!==C&&t!==Q&&(this._lastUsedState=t))}update(t=Math.min(this.clock.getDelta(),64/1e3)){if(!this.enabled||!this.camera||t===0)return;const{camera:e,cameraRadius:i,pivotPoint:o,up:s,state:d,adjustHeight:c,autoAdjustCameraRotation:u}=this;e.updateMatrixWorld(),this.getCameraUpDirection(P),this._upInitialized||(this._upInitialized=!0,this.up.copy(P)),this.zoomPointSet=!1;const l=this._inertiaNeedsUpdate(),n=this.needsUpdate||l;if(this.needsUpdate||l){const r=this.zoomDelta;this._updateZoom(),this._updatePosition(t),this._updateRotation(t),d===E||d===T?(S.set(0,0,-1).transformDirection(e.matrixWorld),this.inertiaTargetDistance=h.copy(o).sub(e.position).dot(S)):d===C&&this._updateInertia(t),(d!==C||r!==0||l)&&this.dispatchEvent(lt),this.needsUpdate=!1}const a=e.isOrthographicCamera?null:c&&this._getPointBelowCamera()||null;if(this.getCameraUpDirection(P),this._setFrame(P),(this.state===E||this.state===T)&&this.actionHeightOffset!==0){const{actionHeightOffset:r}=this;e.position.addScaledVector(s,-r),o.addScaledVector(s,-r),a&&(a.distance-=r)}if(this.actionHeightOffset=0,a){const r=a.distance;if(r<i){const _=i-r;e.position.addScaledVector(s,_),o.addScaledVector(s,_),this.actionHeightOffset=_}}this.pointerTracker.updateFrame(),n&&u&&(this.getCameraUpDirection(P),this._alignCameraUp(P,1),this.getCameraUpDirection(P),this._clampRotation(P))}adjustCamera(t){const{adjustHeight:e,cameraRadius:i}=this;if(t.isPerspectiveCamera){this.getUpDirection(t.position,P);const o=e&&this._getPointBelowCamera(t.position,P)||null;if(o){const s=o.distance;s<i&&t.position.addScaledVector(P,i-s)}}}dispose(){this.detach()}_updateInertia(t){const{rotationInertia:e,pivotPoint:i,dragInertia:o,enableDamping:s,dampingFactor:d,camera:c,cameraRadius:u,minDistance:l,inertiaTargetDistance:n}=this;if(!this.enableDamping||this.inertiaStableFrames>1){o.set(0,0,0),e.set(0,0,0);return}const a=Math.pow(2,-t/d),r=Math.max(c.near,u,l,n),p=.25*(2/(2*1e3));if(e.lengthSq()>0){w(m,h.set(0,0,-1),c),m.applyMatrix4(c.matrixWorldInverse),m.direction.normalize(),m.recast(-m.direction.dot(m.origin)).at(r/m.direction.z,h),h.applyMatrix4(c.matrixWorld),w(m,D.set(p,p,-1),c),m.applyMatrix4(c.matrixWorldInverse),m.direction.normalize(),m.recast(-m.direction.dot(m.origin)).at(r/m.direction.z,D),D.applyMatrix4(c.matrixWorld),h.sub(i).normalize(),D.sub(i).normalize();const y=h.angleTo(D)/t;e.multiplyScalar(a),(e.lengthSq()<y**2||!s)&&e.set(0,0)}if(o.lengthSq()>0){w(m,h.set(0,0,-1),c),m.applyMatrix4(c.matrixWorldInverse),m.direction.normalize(),m.recast(-m.direction.dot(m.origin)).at(r/m.direction.z,h),h.applyMatrix4(c.matrixWorld),w(m,D.set(p,p,-1),c),m.applyMatrix4(c.matrixWorldInverse),m.direction.normalize(),m.recast(-m.direction.dot(m.origin)).at(r/m.direction.z,D),D.applyMatrix4(c.matrixWorld);const y=h.distanceTo(D)/t;o.multiplyScalar(a),(o.lengthSq()<y**2||!s)&&o.set(0,0,0)}e.lengthSq()>0&&this._applyRotation(e.x*t,e.y*t,i),o.lengthSq()>0&&(c.position.addScaledVector(o,t),c.updateMatrixWorld())}_inertiaNeedsUpdate(){const{rotationInertia:t,dragInertia:e}=this;return t.lengthSq()!==0||e.lengthSq()!==0}_updateZoom(){const{zoomPoint:t,zoomDirection:e,camera:i,minDistance:o,maxDistance:s,pointerTracker:d,domElement:c,minZoom:u,maxZoom:l,zoomSpeed:n,state:a}=this;let r=this.zoomDelta;if(this.zoomDelta=0,!(!d.getLatestPoint(v)||r===0&&a!==O))if(this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0),i.isOrthographicCamera){this._updateZoomDirection();const _=this.zoomPointSet||this._updateZoomPoint();q.unproject(i);const x=Math.pow(.95,Math.abs(r*.05));let p=r>0?1/Math.abs(x):x;p*=n,p>1?l<i.zoom*p&&(p=1):u>i.zoom*p&&(p=1),i.zoom*=p,i.updateProjectionMatrix(),_&&(A(v.x,v.y,c,K),K.unproject(i),i.position.sub(K).add(q),i.updateMatrixWorld())}else{this._updateZoomDirection();const _=h.copy(e);if(this.zoomPointSet||this._updateZoomPoint()){const x=t.distanceTo(i.position);if(r<0){const p=Math.min(0,x-s);r=r*x*n*.0025,r=Math.max(r,p)}else{const p=Math.max(0,x-o);r=r*Math.max(x-o,0)*n*.0025,r=Math.min(r,p)}i.position.addScaledVector(e,r),i.updateMatrixWorld()}else{const x=this._getPointBelowCamera();if(x){const p=x.distance;_.set(0,0,-1).transformDirection(i.matrixWorld),i.position.addScaledVector(_,r*p*.01),i.updateMatrixWorld()}}}}_updateZoomDirection(){if(this.zoomDirectionSet)return;const{domElement:t,raycaster:e,camera:i,zoomDirection:o,pointerTracker:s}=this;s.getLatestPoint(v),A(v.x,v.y,t,q),w(e,q,i),o.copy(e.ray.direction).normalize(),this.zoomDirectionSet=!0}_updateZoomPoint(){const{camera:t,zoomDirectionSet:e,zoomDirection:i,raycaster:o,zoomPoint:s,pointerTracker:d,domElement:c}=this;if(this._zoomPointWasSet=!1,!e)return!1;t.isOrthographicCamera&&d.getLatestPoint(F)?(A(F.x,F.y,c,F),w(o,F,t)):(o.ray.origin.copy(t.position),o.ray.direction.copy(i),o.near=0,o.far=1/0);const u=this._raycast(o);return u?(s.copy(u.point),this.zoomPointSet=!0,this._zoomPointWasSet=!0,!0):!1}_getPointBelowCamera(t=this.camera.position,e=this.up){const{raycaster:i}=this;i.ray.direction.copy(e).multiplyScalar(-1),i.ray.origin.copy(t).addScaledVector(e,1e5),i.near=0,i.far=1/0;const o=this._raycast(i);return o&&(o.distance-=1e5),o}_updatePosition(t){const{raycaster:e,camera:i,pivotPoint:o,up:s,pointerTracker:d,domElement:c,state:u,dragInertia:l}=this;if(u===E){if(d.getCenterPoint(v),A(v.x,v.y,c,v),rt.setFromNormalAndCoplanarPoint(s,o),w(e,v,i),Math.abs(e.ray.direction.dot(s))<G){const n=Math.acos(G);Z.crossVectors(e.ray.direction,s).normalize(),e.ray.direction.copy(s).applyAxisAngle(Z,n).multiplyScalar(-1)}if(this.getUpDirection(o,P),Math.abs(e.ray.direction.dot(P))<Y){const n=Math.acos(Y);Z.crossVectors(e.ray.direction,P).normalize(),e.ray.direction.copy(P).applyAxisAngle(Z,n).multiplyScalar(-1)}e.ray.intersectPlane(rt,h)&&(D.subVectors(o,h),i.position.add(D),i.updateMatrixWorld(),D.multiplyScalar(1/t),d.getMoveDistance()/t<2*window.devicePixelRatio?this.inertiaStableFrames++:(l.copy(D),this.inertiaStableFrames=0))}}_updateRotation(t){const{pivotPoint:e,pointerTracker:i,domElement:o,state:s,rotationInertia:d}=this;s===T&&(i.getCenterPoint(v),i.getPreviousCenterPoint(at),V.subVectors(v,at).multiplyScalar(2*Math.PI/o.clientHeight),this._applyRotation(V.x,V.y,e),V.multiplyScalar(1/t),i.getMoveDistance()/t<2*window.devicePixelRatio?this.inertiaStableFrames++:(d.copy(V),this.inertiaStableFrames=0))}_applyRotation(t,e,i){if(t===0&&e===0)return;const{camera:o,minAltitude:s,maxAltitude:d,rotationSpeed:c}=this,u=-t*c;let l=e*c;S.set(0,0,1).transformDirection(o.matrixWorld),b.set(1,0,0).transformDirection(o.matrixWorld),this.getUpDirection(i,P);let n;P.dot(S)>1-1e-10?n=0:(h.crossVectors(P,S).normalize(),n=Math.sign(h.dot(b))*P.angleTo(S)),l>0?(l=Math.min(n-s,l),l=Math.max(0,l)):(l=Math.max(n-d,l),l=Math.min(0,l)),z.setFromAxisAngle(P,u),N(i,z,k),o.matrixWorld.premultiply(k),b.set(1,0,0).transformDirection(o.matrixWorld),z.setFromAxisAngle(b,-l),N(i,z,k),o.matrixWorld.premultiply(k),o.matrixWorld.decompose(o.position,o.quaternion,h)}_setFrame(t){const{up:e,camera:i,zoomPoint:o,zoomDirectionSet:s,zoomPointSet:d,scaleZoomOrientationAtEdges:c}=this;if(s&&(d||this._updateZoomPoint())){if(z.setFromUnitVectors(e,t),c){this.getUpDirection(o,h);let u=Math.max(h.dot(e)-.6,0)/.4;u=B.mapLinear(u,0,.5,0,1),u=Math.min(u,1),i.isOrthographicCamera&&(u*=.1),z.slerp(Mt,1-u)}N(o,z,k),i.updateMatrixWorld(),i.matrixWorld.premultiply(k),i.matrixWorld.decompose(i.position,i.quaternion,h),this.zoomDirectionSet=!1,this._updateZoomDirection()}e.copy(t),i.updateMatrixWorld()}_raycast(t){const{scene:e,useFallbackPlane:i,fallbackPlane:o}=this,s=t.intersectObject(e)[0]||null;if(s)return s;if(i){const d=o;if(t.ray.intersectPlane(d,h))return{point:h.clone(),distance:t.ray.origin.distanceTo(h)}}return null}_alignCameraUp(t,e=1){const{camera:i,state:o,pivotPoint:s,zoomPoint:d,zoomPointSet:c}=this;i.updateMatrixWorld(),S.set(0,0,-1).transformDirection(i.matrixWorld),b.set(-1,0,0).transformDirection(i.matrixWorld);let u=B.mapLinear(1-Math.abs(S.dot(t)),0,.2,0,1);u=B.clamp(u,0,1),e*=u,$.crossVectors(t,S),$.lerp(b,1-e).normalize(),z.setFromUnitVectors(b,$),i.quaternion.premultiply(z);let l=null;o===E||o===T?l=H.copy(s):c&&(l=H.copy(d)),l&&(L.copy(i.matrixWorld).invert(),h.copy(l).applyMatrix4(L),i.updateMatrixWorld(),h.applyMatrix4(i.matrixWorld),j.subVectors(l,h),i.position.add(j)),i.updateMatrixWorld()}_clampRotation(t){const{camera:e,minAltitude:i,maxAltitude:o,state:s,pivotPoint:d,zoomPoint:c,zoomPointSet:u}=this;e.updateMatrixWorld(),S.set(0,0,1).transformDirection(e.matrixWorld),b.set(1,0,0).transformDirection(e.matrixWorld);let l;t.dot(S)>1-1e-10?l=0:(h.crossVectors(t,S),l=Math.sign(h.dot(b))*t.angleTo(S));let n;if(l>o)n=o;else if(l<i)n=i;else return;S.copy(t),z.setFromAxisAngle(b,n),S.applyQuaternion(z).normalize(),h.crossVectors(S,b).normalize(),k.makeBasis(b,h,S),e.quaternion.setFromRotationMatrix(k);let a=null;s===E||s===T?a=H.copy(d):u&&(a=H.copy(c)),a&&(L.copy(e.matrixWorld).invert(),h.copy(a).applyMatrix4(L),e.updateMatrixWorld(),h.applyMatrix4(e.matrixWorld),j.subVectors(a,h),e.position.add(j)),e.updateMatrixWorld()}}export{E as D,Ct as E,C as N,O as Z,A as a,zt as c,N as m,w as s};
//# sourceMappingURL=EnvironmentControls-BDRAm2YU.js.map
