{"version":3,"file":"EPSGTilesPlugin-_FiPb7b9.js","sources":["../../../src/three/plugins/images/utils/getCartographicToMeterDerivative.js","../../../src/three/plugins/images/EllipsoidProjectionTilesPlugin.js","../../../src/three/plugins/images/EPSGTilesPlugin.js"],"sourcesContent":["import { Vector3 } from 'three';\n\nconst _v0 = /* @__PURE__ */ new Vector3();\nconst _v1 = /* @__PURE__ */ new Vector3();\n\nexport function getCartographicToMeterDerivative( ellipsoid, lat, lon ) {\n\n\tconst EPS = 1e-5;\n\tconst lonp = lon + EPS;\n\tlet latp = lat + EPS;\n\tif ( Math.abs( latp ) > Math.PI / 2 ) {\n\n\t\tlatp = latp - EPS;\n\n\t}\n\n\tellipsoid.getCartographicToPosition( lat, lon, 0, _v0 );\n\n\tellipsoid.getCartographicToPosition( latp, lon, 0, _v1 );\n\tconst dy = _v0.distanceTo( _v1 ) / EPS;\n\n\tellipsoid.getCartographicToPosition( lat, lonp, 0, _v1 );\n\tconst dx = _v0.distanceTo( _v1 ) / EPS;\n\n\treturn [ dx, dy ];\n\n}\n","import { ImageFormatPlugin, TILE_LEVEL, TILE_X, TILE_Y } from './ImageFormatPlugin.js';\nimport { MathUtils, PlaneGeometry, Sphere, Vector2, Vector3 } from 'three';\nimport { getCartographicToMeterDerivative } from './utils/getCartographicToMeterDerivative.js';\n\nconst MIN_LON_VERTS = 30;\nconst MIN_LAT_VERTS = 15;\n\nconst _pos = /* @__PURE__ */ new Vector3();\nconst _norm = /* @__PURE__ */ new Vector3();\nconst _uv = /* @__PURE__ */ new Vector2();\nconst _sphere = /* @__PURE__ */ new Sphere();\n\nexport class EllipsoidProjectionTilesPlugin extends ImageFormatPlugin {\n\n\tget projection() {\n\n\t\treturn this.tiling.projection;\n\n\t}\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tshape = 'planar',\n\t\t\tendCaps = true,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( rest );\n\n\t\t// options\n\t\tthis.shape = shape;\n\t\tthis.endCaps = endCaps;\n\n\t}\n\n\t// override the parse to mesh logic to support a region mesh\n\tasync parseToMesh( buffer, tile, ...args ) {\n\n\t\tconst mesh = await super.parseToMesh( buffer, tile, ...args );\n\n\t\t// if displaying the tiles as an ellipsoid\n\t\tconst { shape, projection, tiles, tiling } = this;\n\t\tif ( shape === 'ellipsoid' ) {\n\n\t\t\tconst ellipsoid = tiles.ellipsoid;\n\t\t\tconst level = tile[ TILE_LEVEL ];\n\t\t\tconst x = tile[ TILE_X ];\n\t\t\tconst y = tile[ TILE_Y ];\n\n\t\t\tconst [ minU, minV, maxU, maxV ] = tiling.getTileBounds( x, y, level, true );\n\t\t\tconst [ west, south, east, north ] = tile.boundingVolume.region;\n\n\t\t\t// new geometry\n\t\t\t// default to a minimum number of vertices per degree on each axis\n\t\t\tconst latVerts = Math.ceil( ( north - south ) * MathUtils.RAD2DEG * 0.25 );\n\t\t\tconst lonVerts = Math.ceil( ( east - west ) * MathUtils.RAD2DEG * 0.25 );\n\t\t\tconst yVerts = Math.max( MIN_LAT_VERTS, latVerts );\n\t\t\tconst xVerts = Math.max( MIN_LON_VERTS, lonVerts );\n\t\t\tconst geometry = new PlaneGeometry( 1, 1, xVerts, yVerts );\n\n\t\t\t// adjust the geometry to position it at the region\n\t\t\tconst { position, normal, uv } = geometry.attributes;\n\t\t\tconst vertCount = position.count;\n\t\t\ttile.cached.boundingVolume.getSphere( _sphere );\n\t\t\tfor ( let i = 0; i < vertCount; i ++ ) {\n\n\t\t\t\t_pos.fromBufferAttribute( position, i );\n\t\t\t\t_norm.fromBufferAttribute( normal, i );\n\t\t\t\t_uv.fromBufferAttribute( uv, i );\n\n\t\t\t\tconst lon = MathUtils.mapLinear( _uv.x, 0, 1, west, east );\n\t\t\t\tlet lat = MathUtils.mapLinear( _uv.y, 0, 1, south, north );\n\t\t\t\tif ( projection.isMercator && _uv.y !== 0 && _uv.y !== 1 ) {\n\n\t\t\t\t\t// ensure we have an edge loop positioned at the mercator limit\n\t\t\t\t\t// to avoid UV distortion as much as possible at low LoDs\n\t\t\t\t\tconst latLimit = projection.convertProjectionToLatitude( 1 );\n\t\t\t\t\tconst vStep = 1 / yVerts;\n\n\t\t\t\t\tconst prevLat = MathUtils.mapLinear( _uv.y - vStep, 0, 1, south, north );\n\t\t\t\t\tconst nextLat = MathUtils.mapLinear( _uv.y + vStep, 0, 1, south, north );\n\t\t\t\t\tif ( lat > latLimit && prevLat < latLimit ) {\n\n\t\t\t\t\t\tlat = latLimit;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( lat < - latLimit && nextLat > - latLimit ) {\n\n\t\t\t\t\t\tlat = - latLimit;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tellipsoid.getCartographicToPosition( lat, lon, 0, _pos ).sub( _sphere.center );\n\t\t\t\tellipsoid.getCartographicToNormal( lat, lon, _norm );\n\n\t\t\t\t// update the geometry\n\t\t\t\tconst u = MathUtils.mapLinear( projection.convertLongitudeToProjection( lon ), minU, maxU, 0, 1 );\n\t\t\t\tconst v = MathUtils.mapLinear( projection.convertLatitudeToProjection( lat ), minV, maxV, 0, 1 );\n\t\t\t\tuv.setXY( i, u, v );\n\t\t\t\tposition.setXYZ( i, ..._pos );\n\t\t\t\tnormal.setXYZ( i, ..._norm );\n\n\t\t\t}\n\n\t\t\tmesh.geometry = geometry;\n\t\t\tmesh.position.copy( _sphere.center );\n\n\t\t}\n\n\t\treturn mesh;\n\n\t}\n\n\tcreateBoundingVolume( x, y, level ) {\n\n\t\tif ( this.shape === 'ellipsoid' ) {\n\n\t\t\tconst { tiling, endCaps } = this;\n\t\t\tconst isRoot = level === - 1;\n\t\t\tconst normalizedBounds = isRoot ? tiling.getFullBounds( true ) : tiling.getTileBounds( x, y, level, true );\n\t\t\tconst cartBounds = isRoot ? tiling.getFullBounds() : tiling.getTileBounds( x, y, level );\n\n\t\t\tif ( endCaps ) {\n\n\t\t\t\t// if the north side is at the edge\n\t\t\t\tif ( normalizedBounds[ 3 ] === 1 ) {\n\n\t\t\t\t\tcartBounds[ 3 ] = Math.PI / 2;\n\n\t\t\t\t}\n\n\t\t\t\t// if the south side is at the edge\n\t\t\t\tif ( normalizedBounds[ 1 ] === 0 ) {\n\n\t\t\t\t\tcartBounds[ 1 ] = - Math.PI / 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tregion: [ ...cartBounds, - 1, 1 ],\n\t\t\t};\n\n\t\t} else {\n\n\t\t\treturn super.createBoundingVolume( x, y, level );\n\n\t\t}\n\n\t}\n\n\tpreprocessNode( tile, ...rest ) {\n\n\t\tsuper.preprocessNode( tile, rest );\n\n\t\tconst { shape, projection, tiling } = this;\n\t\tif ( shape === 'ellipsoid' ) {\n\n\t\t\tconst level = tile[ TILE_LEVEL ];\n\t\t\tconst x = tile[ TILE_X ];\n\t\t\tconst y = tile[ TILE_Y ];\n\n\t\t\t// if this is the root node then skip calculating the geometric error\n\t\t\tif ( level === - 1 ) {\n\n\t\t\t\ttile.geometricError = 1e50;\n\t\t\t\treturn parent;\n\n\t\t\t}\n\n\t\t\tconst [ minU, minV, maxU, maxV ] = tiling.getTileBounds( x, y, level, true );\n\t\t\tconst { tilePixelWidth, tilePixelHeight } = tiling.getLevel( level );\n\t\t\tconst { pixelWidth, pixelHeight } = tiling.getLevel( tiling.maxLevel );\n\n\t\t\t// one pixel width in uv space\n\t\t\tconst tileUWidth = ( maxU - minU ) / tilePixelWidth;\n\t\t\tconst tileVWidth = ( maxV - minV ) / tilePixelHeight;\n\t\t\tconst rootUWidth = 1 / pixelWidth;\n\t\t\tconst rootVWidth = 1 / pixelHeight;\n\n\t\t\t// calculate the region ranges\n\t\t\tconst [ /* west */, south, east, north ] = tiling.getTileBounds( x, y, level );\n\n\t\t\t// calculate the changes in lat / lon at the given point\n\t\t\t// find the most bowed point of the latitude range since the amount that latitude changes is\n\t\t\t// dependent on the Y value of the image\n\t\t\tconst midLat = ( south > 0 ) !== ( north > 0 ) ? 0 : Math.min( Math.abs( south ), Math.abs( north ) );\n\t\t\tconst midV = projection.convertLatitudeToProjection( midLat );\n\t\t\tconst lonFactor = projection.getLongitudeDerivativeAtProjection( minU );\n\t\t\tconst latFactor = projection.getLatitudeDerivativeAtProjection( midV );\n\n\t\t\t// TODO: is this correct?\n\n\t\t\t// calculate the size of a pixel on the surface\n\t\t\tconst [ xDeriv, yDeriv ] = getCartographicToMeterDerivative( this.tiles.ellipsoid, midLat, east );\n\t\t\tconst tilePixelWidth2 = Math.max( tileUWidth * lonFactor * xDeriv, tileVWidth * latFactor * yDeriv );\n\t\t\tconst rootPixelWidth = Math.max( rootUWidth * lonFactor * xDeriv, rootVWidth * latFactor * yDeriv );\n\t\t\ttile.geometricError = tilePixelWidth2 - rootPixelWidth;\n\n\t\t\t// if this is the root then keep the geometric error high\n\t\t\tif ( tile.parent === null ) {\n\n\t\t\t\ttile.geometricError = 1e50;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn tile;\n\n\t}\n\n}\n\n","\n// Support for XYZ / Slippy tile systems\n\nimport { EllipsoidProjectionTilesPlugin } from './EllipsoidProjectionTilesPlugin.js';\nimport { XYZImageSource } from './sources/XYZImageSource.js';\nimport { TMSImageSource } from './sources/TMSImageSource.js';\nimport { WMTSImageSource } from './sources/WMTSImageSource.js';\n\n// https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames\nexport class XYZTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\tconst {\n\t\t\tpixelSize = 1e-5,\n\t\t\tlevels,\n\t\t\ttileDimension,\n\t\t\tprojection,\n\t\t\tbounds,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( { pixelSize, ...rest } );\n\n\t\tthis.name = 'XYZ_TILES_PLUGIN';\n\t\tthis.imageSource = new XYZImageSource( { levels, tileDimension, projection, bounds } );\n\n\t}\n\n}\n\n// Support for TMS tiles\n// https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification\n// NOTE: Most, if not all, TMS generation implementations do not correctly support the Origin tag\n// and tile index offsets, including CesiumJS and Ion.\nexport class TMSTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options ) {\n\n\t\tsuper( options );\n\n\t\tthis.name = 'TMS_TILES_PLUGIN';\n\t\tthis.imageSource = new TMSImageSource();\n\n\t}\n\n}\n\n// Support for WMTS tiles via a url template\nexport class WMTSTilesPlugin extends EllipsoidProjectionTilesPlugin {\n\n\tconstructor( options = {} ) {\n\n\t\t// TODO: support WMTS capabilities request xml\n\t\tconst {\n\t\t\tpixelSize = 1e-5,\n\t\t\tlevels,\n\t\t\ttileDimension,\n\t\t\tprojection,\n\t\t\tbounds,\n\t\t\t...rest\n\t\t} = options;\n\n\t\tsuper( { pixelSize, ...rest } );\n\n\t\tthis.name = 'WTMS_TILES_PLUGIN';\n\t\tthis.imageSource = new WMTSImageSource( { levels, tileDimension, projection, bounds } );\n\n\t}\n\n}\n"],"names":["_v0","Vector3","_v1","getCartographicToMeterDerivative","ellipsoid","lat","lon","lonp","latp","dy","MIN_LON_VERTS","MIN_LAT_VERTS","_pos","_norm","_uv","Vector2","_sphere","Sphere","EllipsoidProjectionTilesPlugin","ImageFormatPlugin","options","shape","endCaps","rest","buffer","tile","args","mesh","projection","tiles","tiling","level","TILE_LEVEL","x","TILE_X","y","TILE_Y","minU","minV","maxU","maxV","west","south","east","north","latVerts","MathUtils","lonVerts","yVerts","xVerts","geometry","PlaneGeometry","position","normal","uv","vertCount","i","latLimit","vStep","prevLat","nextLat","u","v","isRoot","normalizedBounds","cartBounds","tilePixelWidth","tilePixelHeight","pixelWidth","pixelHeight","tileUWidth","tileVWidth","rootUWidth","rootVWidth","midLat","midV","lonFactor","latFactor","xDeriv","yDeriv","tilePixelWidth2","rootPixelWidth","XYZTilesPlugin","pixelSize","levels","tileDimension","bounds","XYZImageSource","TMSTilesPlugin","TMSImageSource"],"mappings":"gNAEA,MAAMA,EAAsB,IAAIC,EAC1BC,EAAsB,IAAID,EAEzB,SAASE,GAAkCC,EAAWC,EAAKC,EAAM,CAGvE,MAAMC,EAAOD,EAAM,KACnB,IAAIE,EAAOH,EAAM,KACZ,KAAK,IAAKG,CAAM,EAAG,KAAK,GAAK,IAEjCA,EAAOA,EAAO,MAIfJ,EAAU,0BAA2BC,EAAKC,EAAK,EAAGN,CAAK,EAEvDI,EAAU,0BAA2BI,EAAMF,EAAK,EAAGJ,CAAK,EACxD,MAAMO,EAAKT,EAAI,WAAYE,CAAK,EAAG,KAEnC,OAAAE,EAAU,0BAA2BC,EAAKE,EAAM,EAAGL,CAAK,EAGjD,CAFIF,EAAI,WAAYE,CAAK,EAAG,KAEtBO,CAAI,CAElB,CCtBA,MAAMC,GAAgB,GAChBC,GAAgB,GAEhBC,EAAuB,IAAIX,EAC3BY,EAAwB,IAAIZ,EAC5Ba,EAAsB,IAAIC,GAC1BC,EAA0B,IAAIC,EAE7B,MAAMC,UAAuCC,CAAkB,CAErE,IAAI,YAAa,CAEhB,OAAO,KAAK,OAAO,UAErB,CAEC,YAAaC,EAAU,GAAK,CAE3B,KAAM,CACL,MAAAC,EAAQ,SACR,QAAAC,EAAU,GACV,GAAGC,CACN,EAAMH,EAEJ,MAAOG,CAAM,EAGb,KAAK,MAAQF,EACb,KAAK,QAAUC,CAEjB,CAGC,MAAM,YAAaE,EAAQC,KAASC,EAAO,CAE1C,MAAMC,EAAO,MAAM,MAAM,YAAaH,EAAQC,EAAM,GAAGC,CAAM,EAGvD,CAAE,MAAAL,EAAO,WAAAO,EAAY,MAAAC,EAAO,OAAAC,CAAQ,EAAG,KAC7C,GAAKT,IAAU,YAAc,CAE5B,MAAMjB,EAAYyB,EAAM,UAClBE,EAAQN,EAAMO,CAAY,EAC1BC,EAAIR,EAAMS,CAAQ,EAClBC,EAAIV,EAAMW,CAAQ,EAElB,CAAEC,EAAMC,EAAMC,EAAMC,CAAM,EAAGV,EAAO,cAAeG,EAAGE,EAAGJ,EAAO,EAAM,EACtE,CAAEU,EAAMC,EAAOC,EAAMC,GAAUnB,EAAK,eAAe,OAInDoB,EAAW,KAAK,MAAQD,EAAQF,GAAUI,EAAU,QAAU,GAAM,EACpEC,EAAW,KAAK,MAAQJ,EAAOF,GAASK,EAAU,QAAU,GAAM,EAClEE,EAAS,KAAK,IAAKrC,GAAekC,CAAU,EAC5CI,EAAS,KAAK,IAAKvC,GAAeqC,CAAU,EAC5CG,EAAW,IAAIC,EAAe,EAAG,EAAGF,EAAQD,CAAQ,EAGpD,CAAE,SAAAI,EAAU,OAAAC,EAAQ,GAAAC,CAAI,EAAGJ,EAAS,WACpCK,EAAYH,EAAS,MAC3B3B,EAAK,OAAO,eAAe,UAAWT,CAAS,EAC/C,QAAUwC,EAAI,EAAGA,EAAID,EAAWC,IAAO,CAEtC5C,EAAK,oBAAqBwC,EAAUI,CAAG,EACvC3C,EAAM,oBAAqBwC,EAAQG,CAAG,EACtC1C,EAAI,oBAAqBwC,EAAIE,CAAG,EAEhC,MAAMlD,EAAMwC,EAAU,UAAWhC,EAAI,EAAG,EAAG,EAAG2B,EAAME,CAAM,EAC1D,IAAItC,EAAMyC,EAAU,UAAWhC,EAAI,EAAG,EAAG,EAAG4B,EAAOE,CAAO,EAC1D,GAAKhB,EAAW,YAAcd,EAAI,IAAM,GAAKA,EAAI,IAAM,EAAI,CAI1D,MAAM2C,EAAW7B,EAAW,4BAA6B,CAAG,EACtD8B,EAAQ,EAAIV,EAEZW,EAAUb,EAAU,UAAWhC,EAAI,EAAI4C,EAAO,EAAG,EAAGhB,EAAOE,CAAO,EAClEgB,EAAUd,EAAU,UAAWhC,EAAI,EAAI4C,EAAO,EAAG,EAAGhB,EAAOE,CAAO,EACnEvC,EAAMoD,GAAYE,EAAUF,IAEhCpD,EAAMoD,GAIFpD,EAAM,CAAEoD,GAAYG,EAAU,CAAEH,IAEpCpD,EAAM,CAAEoD,EAId,CAEIrD,EAAU,0BAA2BC,EAAKC,EAAK,EAAGM,GAAO,IAAKI,EAAQ,MAAQ,EAC9EZ,EAAU,wBAAyBC,EAAKC,EAAKO,CAAO,EAGpD,MAAMgD,EAAIf,EAAU,UAAWlB,EAAW,6BAA8BtB,CAAG,EAAI+B,EAAME,EAAM,EAAG,CAAG,EAC3FuB,EAAIhB,EAAU,UAAWlB,EAAW,4BAA6BvB,CAAG,EAAIiC,EAAME,EAAM,EAAG,CAAG,EAChGc,EAAG,MAAOE,EAAGK,EAAGC,CAAG,EACnBV,EAAS,OAAQI,EAAG,GAAG5C,CAAM,EAC7ByC,EAAO,OAAQG,EAAG,GAAG3C,CAAO,CAEhC,CAEGc,EAAK,SAAWuB,EAChBvB,EAAK,SAAS,KAAMX,EAAQ,MAAQ,CAEvC,CAEE,OAAOW,CAET,CAEC,qBAAsBM,EAAGE,EAAGJ,EAAQ,CAEnC,GAAK,KAAK,QAAU,YAAc,CAEjC,KAAM,CAAE,OAAAD,EAAQ,QAAAR,CAAO,EAAK,KACtByC,EAAShC,IAAU,GACnBiC,EAAmBD,EAASjC,EAAO,cAAe,EAAI,EAAKA,EAAO,cAAeG,EAAGE,EAAGJ,EAAO,EAAM,EACpGkC,EAAaF,EAASjC,EAAO,cAAa,EAAKA,EAAO,cAAeG,EAAGE,EAAGJ,CAAO,EAExF,OAAKT,IAGC0C,EAAkB,CAAG,IAAK,IAE9BC,EAAY,CAAC,EAAK,KAAK,GAAK,GAKxBD,EAAkB,CAAG,IAAK,IAE9BC,EAAY,CAAG,EAAG,CAAE,KAAK,GAAK,IAMzB,CACN,OAAQ,CAAE,GAAGA,EAAY,GAAK,CAAG,CACjC,CAEJ,KAEG,QAAO,MAAM,qBAAsBhC,EAAGE,EAAGJ,CAAO,CAInD,CAEC,eAAgBN,KAASF,EAAO,CAE/B,MAAM,eAAgBE,EAAMF,CAAM,EAElC,KAAM,CAAE,MAAAF,EAAO,WAAAO,EAAY,OAAAE,CAAQ,EAAG,KACtC,GAAKT,IAAU,YAAc,CAE5B,MAAMU,EAAQN,EAAMO,CAAY,EAC1BC,EAAIR,EAAMS,CAAQ,EAClBC,EAAIV,EAAMW,CAAQ,EAGxB,GAAKL,IAAU,GAEd,OAAAN,EAAK,eAAiB,KACf,OAIR,KAAM,CAAEY,EAAMC,EAAMC,EAAMC,CAAM,EAAGV,EAAO,cAAeG,EAAGE,EAAGJ,EAAO,EAAM,EACtE,CAAE,eAAAmC,EAAgB,gBAAAC,CAAe,EAAKrC,EAAO,SAAUC,CAAO,EAC9D,CAAE,WAAAqC,EAAY,YAAAC,CAAa,EAAGvC,EAAO,SAAUA,EAAO,QAAU,EAGhEwC,GAAe/B,EAAOF,GAAS6B,EAC/BK,GAAe/B,EAAOF,GAAS6B,EAC/BK,EAAa,EAAIJ,EACjBK,EAAa,EAAIJ,EAGjB,CAAc,CAAA3B,EAAOC,EAAMC,CAAO,EAAGd,EAAO,cAAeG,EAAGE,EAAGJ,CAAO,EAKxE2C,EAAWhC,EAAQ,GAAUE,EAAQ,EAAM,EAAI,KAAK,IAAK,KAAK,IAAKF,CAAK,EAAI,KAAK,IAAKE,EAAS,EAC/F+B,EAAO/C,EAAW,4BAA6B8C,CAAQ,EACvDE,EAAYhD,EAAW,mCAAoCS,CAAM,EACjEwC,EAAYjD,EAAW,kCAAmC+C,CAAM,EAKhE,CAAEG,EAAQC,CAAM,EAAK5E,GAAkC,KAAK,MAAM,UAAWuE,EAAQ/B,CAAM,EAC3FqC,EAAkB,KAAK,IAAKV,EAAaM,EAAYE,EAAQP,EAAaM,EAAYE,CAAQ,EAC9FE,EAAiB,KAAK,IAAKT,EAAaI,EAAYE,EAAQL,EAAaI,EAAYE,CAAQ,EACnGtD,EAAK,eAAiBuD,EAAkBC,EAGnCxD,EAAK,SAAW,OAEpBA,EAAK,eAAiB,KAI1B,CAEE,OAAOA,CAET,CAEA,CChNO,MAAMyD,WAAuBhE,CAA+B,CAElE,YAAaE,EAAU,GAAK,CAE3B,KAAM,CACL,UAAA+D,EAAY,KACZ,OAAAC,EACA,cAAAC,EACA,WAAAzD,EACA,OAAA0D,EACA,GAAG/D,CACN,EAAMH,EAEJ,MAAO,CAAE,UAAA+D,EAAW,GAAG5D,EAAQ,EAE/B,KAAK,KAAO,mBACZ,KAAK,YAAc,IAAIgE,GAAgB,CAAE,OAAAH,EAAQ,cAAAC,EAAe,WAAAzD,EAAY,OAAA0D,EAAU,CAExF,CAEA,CAMO,MAAME,WAAuBtE,CAA+B,CAElE,YAAaE,EAAU,CAEtB,MAAOA,CAAS,EAEhB,KAAK,KAAO,mBACZ,KAAK,YAAc,IAAIqE,EAEzB,CAEA"}