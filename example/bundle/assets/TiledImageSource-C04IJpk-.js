import{aK as B,y as P,bp as L}from"./three.module-CQU0seT4.js";function v(...x){return x.join("_")}class j{constructor(){this.cache={},this.count=0,this.cachedBytes=0,this.active=0}fetchItem(){}disposeItem(){}getMemoryUsage(t){return 0}setData(...t){const{cache:i}=this,e=t.pop(),o=v(...t);if(o in i)throw new Error(`DataCache: "${o}" is already present.`);return this.cache[o]={abortController:new AbortController,result:e,count:1,bytes:this.getMemoryUsage(e)},this.count++,this.cachedBytes+=this.cache[o].bytes,e}lock(...t){const{cache:i}=this,e=v(...t);if(e in i)i[e].count++;else{const o=new AbortController,s={abortController:o,result:null,count:1,bytes:0};this.active++,s.result=this.fetchItem(t,o.signal),s.result instanceof Promise?s.result.then(n=>(s.result=n,s.bytes=this.getMemoryUsage(n),this.cachedBytes+=s.bytes,n)).finally(()=>{this.active--}).catch(n=>{}):(this.active--,s.bytes=this.getMemoryUsage(s.result),this.cachedBytes+=s.bytes),this.cache[e]=s,this.count++}return i[e].result}release(...t){const i=v(...t);this.releaseViaFullKey(i)}get(...t){const{cache:i}=this,e=v(...t);return e in i&&i[e].count>0?i[e].result:null}has(...t){const{cache:i}=this;return v(...t)in i}dispose(){const{cache:t}=this;for(const i in t){const{abortController:e}=t[i];e.abort(),this.releaseViaFullKey(i,!0)}this.cache={}}releaseViaFullKey(t,i=!1){const{cache:e}=this;if(t in e&&e[t].count>0){const o=e[t];if(o.count--,o.count===0||i){const s=()=>{if(e[t]!==o)return;const{result:n,abortController:r}=o;r.abort(),n instanceof Promise?n.then(c=>{this.disposeItem(c),this.count--,this.cachedBytes-=o.bytes}).catch(()=>{}):(this.disposeItem(n),this.count--,this.cachedBytes-=o.bytes),delete e[t]};i?s():queueMicrotask(()=>{o.count===0&&s()})}return!0}throw new Error("DataCache: Attempting to release key that does not exist")}}function m(x,t,i){return Math.min(Math.max(x,t),i)}class C{get levelCount(){return this._levels.length}get maxLevel(){return this.levelCount-1}get minLevel(){const t=this._levels;for(let i=0;i<t.length;i++)if(t[i]!==null)return i;return-1}get rootBounds(){var t;return this._rootBounds??((t=this.projection)==null?void 0:t.getBounds())??[0,0,1,1]}get rootOrigin(){const t=this.rootBounds;return this._rootOrigin??[t[0],t[1]]}get aspectRatio(){const{pixelWidth:t,pixelHeight:i}=this.getLevel(this.maxLevel);return t/i}constructor(){this.flipY=!1,this.pixelOverlap=0,this._rootBounds=null,this._rootOrigin=null,this.projection=null,this._levels=[]}setLevel(t,i={}){const e=this._levels;for(;e.length<t;)e.push(null);const{tilePixelWidth:o=256,tilePixelHeight:s=256,tileCountX:n=2**t,tileCountY:r=2**t}=i,{pixelWidth:c=o*n,pixelHeight:l=s*r}=i;e[t]={tilePixelWidth:o,tilePixelHeight:s,pixelWidth:c,pixelHeight:l,tileCountX:n,tileCountY:r}}generateLevels(t,i,e,o={}){const{minLevel:s=0,tilePixelWidth:n=256,tilePixelHeight:r=256}=o,c=t-1,{pixelWidth:l=n*i*2**c,pixelHeight:g=r*e*2**c}=o;for(let h=s;h<t;h++){const a=t-h-1,u=Math.ceil(l*2**-a),f=Math.ceil(g*2**-a),d=Math.ceil(u/n),p=Math.ceil(f/r);this.setLevel(h,{tilePixelWidth:n,tilePixelHeight:r,pixelWidth:u,pixelHeight:f,tileCountX:d,tileCountY:p})}}getLevel(t){return this._levels[t]}setOrigin(t,i){this._rootOrigin=[t,i]}setBounds(t,i,e,o){this._rootBounds=[t,i,e,o]}setProjection(t){this.projection=t}getTileAtPoint(t,i,e,o=!1){const{projection:s,flipY:n}=this,{tileCountX:r,tileCountY:c}=this.getLevel(e),l=1/r,g=1/c;s&&!o&&(t=s.convertLongitudeToProjection(t),i=s.convertLatitudeToProjection(i));const h=Math.floor(t/l);let a=Math.floor(i/g);return n&&(a=c-1-a),[h,a]}getTilesInRange(t,i,e,o,s,n=!1){const r=this.getTileAtPoint(t,i,s,n,!1),c=this.getTileAtPoint(e,o,s,n,!1);this.flipY&&([r[1],c[1]]=[c[1],r[1]]);const{tileCountX:l,tileCountY:g}=this.getLevel(s),[h,a]=r,[u,f]=c;return u<0||f<0||h>=l||a>=g?[0,0,-1,-1]:[m(h,0,l-1),m(a,0,g-1),m(u,0,l-1),m(f,0,g-1)]}getTileExists(t,i,e){const[o,s,n,r]=this.rootBounds,[c,l,g,h]=this.getTileBounds(t,i,e);return!(c>=g||l>=h)&&c<=n&&l<=r&&g>=o&&h>=s}getFullBounds(t=!1){const{projection:i}=this,e=[...this.rootBounds];return i&&t&&(e[0]=i.convertLongitudeToProjection(e[0]),e[1]=i.convertLatitudeToProjection(e[1]),e[2]=i.convertLongitudeToProjection(e[2]),e[3]=i.convertLatitudeToProjection(e[3])),e}getTileBounds(t,i,e,o=!1){const{flipY:s,pixelOverlap:n,projection:r}=this,{tilePixelWidth:c,tilePixelHeight:l,pixelWidth:g,pixelHeight:h}=this.getLevel(e);let a=c*t-n,u=l*i-n,f=a+c+n*2,d=u+l+n*2;if(a=Math.max(a,0),u=Math.max(u,0),f=Math.min(f,g),d=Math.min(d,h),a=a/g,f=f/g,u=u/h,d=d/h,s){const y=(d-u)/2,T=1-(u+d)/2;u=T-y,d=T+y}const p=[a,u,f,d];return r&&!o&&(p[0]=r.convertProjectionToLongitude(p[0]),p[1]=r.convertProjectionToLatitude(p[1]),p[2]=r.convertProjectionToLongitude(p[2]),p[3]=r.convertProjectionToLatitude(p[3])),p}toNormalizedPoint(t,i){const{projection:e}=this,o=[t,i];return this.projection&&(o[0]=e.convertLongitudeToProjection(o[0]),o[1]=e.convertLatitudeToProjection(o[1])),o}toNormalizedRange(t){return[...this.toNormalizedPoint(t[0],t[1]),...this.toNormalizedPoint(t[2],t[3])]}clampToBounds(t,i=!1){const e=[...t],{projection:o}=this;if(i||!o)e[0]=m(e[0],0,1),e[1]=m(e[1],0,1),e[2]=m(e[2],0,1),e[3]=m(e[3],0,1);else{const[s,n,r,c]=o.getBounds();e[0]=m(e[0],s,r),e[1]=m(e[1],n,c),e[2]=m(e[2],s,r),e[3]=m(e[3],n,c)}return e}}class Y extends j{constructor(){super(),this.tiling=new C,this.fetchOptions={},this.fetchData=(...t)=>fetch(...t)}init(t){}async processBufferToTexture(t){const i=new Blob([t]),e=await createImageBitmap(i,{premultiplyAlpha:"none",colorSpaceConversion:"none",imageOrientation:"flipY"}),o=new B(e);return o.generateMipmaps=!1,o.colorSpace=P,o.needsUpdate=!0,o}getMemoryUsage(t){const{TextureUtils:i}=L;if(!i)return 0;const{format:e,type:o,image:s,generateMipmaps:n}=t,{width:r,height:c}=s,l=i.getByteLength(r,c,e,o);return n?l*4/3:l}fetchItem(t,i){const e={...this.fetchOptions,signal:i},o=this.getUrl(...t);return this.fetchData(o,e).then(s=>s.arrayBuffer()).then(s=>this.processBufferToTexture(s))}disposeItem(t){t.dispose(),t.image instanceof ImageBitmap&&t.image.close()}getUrl(...t){}}export{Y as T,C as a};
//# sourceMappingURL=TiledImageSource-C04IJpk-.js.map
